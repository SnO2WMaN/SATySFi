@require: pervasives
@require: list
@require: gr

module Math :> sig

  val \math : inline [math-text]
  val +math : block [?(tag : inline-text) math-text]
  val \eqn : inline [?(tag : inline-text) math-text]
  val +math-list : block [list math-text]
  val \math-list : inline [list math-text]
  val +align : block [list (list math-text)]
  val \align : inline [list (list math-text)]
  val \text : math [inline-text]
  val \frac : math [math-text, math-text]
  val \sqrt : math [math-text]
  val \lower : math [math-text, math-text]
  val \upper : math [math-text, math-text]
  val \math-skip : math [length]
  val \math-color : math [color, math-text]
  val join : math-text -> list math-text -> math-text
  val half-length : length -> length -> length -> length -> length

  val \mathord : math [math-text]
  val \mathbin : math [math-text]
  val \mathrel : math [math-text]
  val \mathop : math [math-text]
  val \mathprefix : math [math-text]
  val \mathpunct : math [math-text]

  val \math-style : math [math-char-class, math-text]
  val \mathrm : math [math-text]
  val \mathbf : math [math-text]
  val \mathcal : math [math-text]
  val \mathfrak : math [math-text]
  val \mathbb : math [math-text]
  val \bm : math [math-text]

  val \math-style-token : math [math-char-class, string]
  val \mathit-token : math [string]
  val \mathrm-token : math [string]
  val \mathbf-token : math [string]

  val \alpha   : math []
  val \beta    : math []
  val \gamma   : math []
  val \delta   : math []
  val \epsilon : math []
  val \zeta    : math []
  val \eta     : math []
  val \theta   : math []
  val \iota    : math []
  val \kappa   : math []
  val \lambda  : math []
  val \mu      : math []
  val \nu      : math []
  val \xi      : math []
  val \omicron : math []
  val \pi      : math []
  val \rho     : math []
  val \sigma   : math []
  val \tau     : math []
  val \upsilon : math []
  val \phi     : math []
  val \chi     : math []
  val \psi     : math []
  val \omega   : math []

  val \Alpha   : math []
  val \Beta    : math []
  val \Gamma   : math []
  val \Delta   : math []
  val \Epsilon : math []
  val \Zeta    : math []
  val \Eta     : math []
  val \Theta   : math []
  val \Iota    : math []
  val \Kappa   : math []
  val \Lambda  : math []
  val \Mu      : math []
  val \Nu      : math []
  val \Xi      : math []
  val \Omicron : math []
  val \Pi      : math []
  val \Rho     : math []
  val \Sigma   : math []
  val \Tau     : math []
  val \Upsilon : math []
  val \Phi     : math []
  val \Chi     : math []
  val \Psi     : math []
  val \Omega   : math []

  val \to : math []
  val \pm : math []
  val \mp : math []
  val \times : math []
  val \setminus : math []
  val \ast : math []
  val \circ : math []
  val \bullet : math []
  val \cap : math []
  val \cup : math []
  val \uplus : math []
  val \sqcap : math []
  val \sqcup : math []
  val \wedge : math []
  val \vee : math []
  val \oplus : math []
  val \ominus : math []
  val \otimes : math []
  val \oslash : math []

  val \vdash : math []
  val \nvdash : math []
  val \dashv : math []
  val \vDash : math []
  val \nvDash : math []
  val \Vdash : math []
  val \nVdash : math []

  val \colon-rel : math []

  val \leq : math []
  val \geq : math []
  val \equiv : math []
  val \nequiv : math []
  val \neq : math []
  val \sim : math []
  val \nsim : math []
  val \simeq : math []
  val \nsimeq : math []
  val \propto : math []
  val \coloneq : math []
  val \eqcolon : math []

  val \in : math []
  val \nin : math []
  val \ni : math []
  val \nni : math []
  val \subset : math []
  val \supset : math []
  val \nsubset : math []
  val \nsupset : math []
  val \subseteq : math []
  val \supseteq : math []
  val \nsubseteq : math []
  val \nsupseteq : math []
  val \subsetneq : math []
  val \supsetneq : math []
  val \sqsubset : math []
  val \sqsupset : math []
  val \sqsubseteq : math []
  val \sqsupseteq : math []
  val \nsqsubseteq : math []
  val \nsqsupseteq : math []
  val \sqsubsetneq : math []
  val \sqsupsetneq : math []
  val \prec : math []
  val \succ : math []
  val \nprec : math []
  val \nsucc : math []
  val \preccurlyeq : math []
  val \succcurlyeq : math []
  val \precsim : math []
  val \succsim : math []
  val \npreccurlyeq : math []
  val \nsucccurlyeq : math []

  val \emptyset : math []
  val \infty : math []
  val \top : math []
  val \bot : math []
  val \therefore : math []
  val \because : math []
  val \forall : math []
  val \exists : math []
  val \nexists : math []
  val \bigcirc : math []

  val \cdot  : math []
  val \ldots : math []
  val \cdots : math []
  val \vdots : math []
  val \ddots : math []
  val \backddots : math []

  val \lim : math []
  val \colim : math []
  val \max : math []
  val \min : math []
  val \inf : math []
  val \sup : math []
  val \sin : math []
  val \cos : math []
  val \tan : math []
  val \cot : math []
  val \sec : math []
  val \csc : math []
  val \log : math []
  val \tr : math []
  val \det : math []
  val \dom : math []
  val \cod : math []
  val \Ker : math []
  val \Im : math []

  val \sum : math []
  val \prod : math []
  val \coprod : math []
  val \bigwedge : math []
  val \bigvee : math []
  val \bigcap : math []
  val \bigcup : math []

  val \lnot : math []
  val \land : math []
  val \lor : math []

  val \Leftarrow : math []
  val \Rightarrow : math []
  val \Leftrightarrow : math []
  val \Uparrow : math []
  val \Downarrow : math []
  val \Updownarrow : math []
  val \nRightarrow : math []
  val \nLeftarrow : math []
  val \nLeftrightarrow : math []
  val \leftarrow : math []
  val \rightarrow : math []
  val \uparrow : math []
  val \downarrow : math []
  val \updownarrow : math []
  val \nwarrow : math []
  val \nearrow : math []
  val \searrow : math []
  val \swarrow : math []
  val \nleftarrow : math []
  val \nrightarrow : math []
  val \nleftrightarrow : math []
  val \mapsto : math []
  val \hookleftarrow : math []
  val \hookrightarrow : math []
  val \rightarrowtail : math []
  val \leftarrowtail : math []
  val \twoheadleftarrow : math []
  val \twoheadrightarrow : math []
  val \twoheaduparrow : math []
  val \twoheaddownarrow : math []
  val \leftharpoonup : math []
  val \leftharpoondown : math []
  val \rightharpoonup : math []
  val \rightharpoondown : math []
  val \rightleftharpoons : math []
  val \upharpoonright : math []
  val \upharpoonleft : math []
  val \downharpoonright : math []
  val \downharpoonleft : math []
  val \longleftarrow : math []
  val \longrightarrow : math []
  val \longleftrightarrow : math []
  val \Longleftarrow : math []
  val \Longrightarrow : math []
  val \Longleftrightarrow : math []
  val \circlearrowleft : math []
  val \circlearrowright : math []

  val \between : math []
  val \pitchfork : math []
  val \intercal : math []
  val \ll : math []
  val \gg : math []
  val \lll : math []
  val \ggg : math []
  val \leqq : math []
  val \geqq : math []
  val \lneqq : math []
  val \gneqq : math []
  val \lnsim : math []
  val \gnsim : math []
  val \precnsim : math []
  val \succnsim : math []
  val \Subset : math []
  val \Supset : math []
  val \Cap : math []
  val \Cup : math []
  val \lhd : math []
  val \rhd : math []
  val \unlhd : math []
  val \unrhd : math []
  val \triangleleft : math []
  val \triangleright : math []
  val \trianglelefteq : math []
  val \trianglerighteq : math []
  val \backsim : math []
  val \backsimeq : math []
  val \eqcirc : math []
  val \cong : math []
  val \simneq : math []
  val \ncong : math []
  val \approx : math []
  val \napprox : math []
  val \approxeq : math []
  val \curlyeqprec : math []
  val \curlyeqsucc : math []
  val \lessdot : math []
  val \gtrdot : math []
  val \lesssim : math []
  val \gtrsim : math []
  val \nlesssim : math []
  val \ngtrsim : math []
  val \lessgtr : math []
  val \gtrless : math []
  val \nlessgtr : math []
  val \ngtrless : math []
  val \ntriangleleft : math []
  val \ntriangleright : math []
  val \ntrianglelefteq : math []
  val \ntrianglerighteq : math []
  val \lesseqgtr : math []
  val \gtreqless : math []
  val \nless : math []
  val \ngtr : math []
  val \nleq : math []
  val \ngeq : math []
  val \asymp : math []
  val \nasymp : math []
  val \circeq : math []
  val \Bumpeq : math []
  val \bumpeq : math []
  val \doteq : math []
  val \doteqdot : math []
  val \fallingdotseq : math []
  val \risingdotseq : math []
  val \mid : math []
  val \nmid : math []
  val \parallel : math []
  val \nparallel : math []
  val \Vvdash : math []
  val \VDash : math []
  val \coloncoloneq : math []
  val \leqslant : math []
  val \geqslant : math []
  val \dashV : math []
  val \Dashv : math []
  val \DashV : math []
  val \preceq : math []
  val \succeq : math []

  val \amalg : math []
  val \dotplus : math []
  val \divideontimes : math []
  val \odot : math []
  val \circledcirc : math []
  val \circledast : math []
%  val \circledeq : math []
  val \circleddash : math []
  val \boxplus : math []
  val \boxminus : math []
  val \boxtimes : math []
  val \boxdot : math []
  val \curlyvee : math []
  val \curlywedge : math []
  val \Join : math []
  val \ltimes : math []
  val \rtimes : math []
  val \leftthreetimes : math []
  val \rightthreetimes : math []
  val \wr : math []

  val \diamond : math []
  val \star : math []
  val \complement : math []
  val \angle : math []
  val \measuredangle : math []
  val \sphericalangle : math []

  val \int : math []

  val \ordd : math []
  val \partial : math []
  val \nabla : math []

  val \paren : math [math-text]
  val \app : math [math-text, math-text]
  val \angle-bracket : math [math-text]
  val \brace : math [math-text]
  val \sqbracket : math [math-text]
  val \abs : math [math-text]
  val \norm : math [math-text]
  val \floor : math [math-text]
  val \ceil : math [math-text]
  val \set : math [math-text]
  val \setsep : math [math-text, math-text]
  val \cases : math [list (math-text * inline-text)]

  type paren = Pervasives.paren %TODO (enhance): remove this
  val paren-left : paren
  val paren-right : paren
  val angle-left : length -> paren
  val angle-right : length -> paren
  val brace-left : paren
  val brace-right : paren
  val sqbracket-left : paren
  val sqbracket-right : paren
  val floor-left : paren
  val floor-right : paren
  val ceil-left : paren
  val ceil-right : paren
  val abs-left : paren
  val abs-right : paren
  val norm-left : paren
  val norm-right : paren
  val empty-paren : paren
  val bar-middle : paren
  val slash-middle : paren

%   % -- temporary -- %TODO: remove this
   val \synteq : math []
   val \tyjd : math [math-text, math-text, math-text]
   val \and-also : math []
   val \tmabstyped : math [math-text, math-text, math-text]
%
end = struct

  val join msep mlst =
    match
      mlst |> List.fold-left (fun maccopt m -> (
        match maccopt with
        | None       -> Some(m)
        | Some(macc) -> Some(${#macc #msep #m})
        end
      )) None
    with
    | None       -> ${}
    | Some(macc) -> macc
    end


  val margin-ratio = 1.


  val inline ctx \math fml =
    script-guard Latin (embed-math ctx fml)

  val math \frac = math-frac

  val math \sqrt = math-radical None

  val math \lower = math-lower

  val math \upper = math-upper

  val math \text it =
    text-in-math MathOrd (fun ctx -> read-inline ctx it)

  val math \math-skip len =
    text-in-math MathOrd (fun _ -> inline-skip len)

  val math \math-color color m =
    math-color color m


  val math \mathord = math-group MathOrd MathOrd
  val math \mathbin = math-group MathBin MathBin
  val math \mathrel = math-group MathRel MathRel
  val math \mathop = math-group MathOp MathOp
  val math \mathprefix = math-group MathPrefix MathPrefix
  val math \mathpunct = math-group MathPunct MathPunct

  val math \math-style sty m =
    math-char-class sty m

  val math \mathrm m = ${\math-style!(MathRoman){#m}}
  val math \mathbf m = ${\math-style!(MathBoldRoman){#m}}
  val math \mathcal m = ${\math-style!(MathScript){#m}}
  val math \mathfrak m = ${\math-style!(MathFraktur){#m}}
  val math \mathbb m = ${\math-style!(MathDoubleStruck){#m}}
  val math \bm m = ${\math-style!(MathBoldItalic){#m}}


  val math \math-style-token sty s =
    text-in-math MathOrd (fun ctx -> (
      let sm = convert-string-for-math ctx sty s in
      embed-math ctx (math-char MathOrd sm)
    ))

  val math \mathit-token s = ${\math-style-token!(MathItalic)!(s)}
  val math \mathrm-token s = ${\math-style-token!(MathRoman)!(s)}
  val math \mathbf-token s = ${\math-style-token!(MathBoldRoman)!(s)}


  val math-scheme ctx tagopt m =
    let ib = embed-math ctx m in
      match tagopt with
      | None      -> line-break true true ctx (inline-fil ++ ib ++ inline-fil)
      | Some(tag) -> line-break true true ctx (inline-fil ++ ib ++ inline-fil ++ read-inline ctx tag)
      end


  val block ctx +math ?(tag = tagopt) m =
    math-scheme ctx tagopt m


  val inline ctx \eqn ?(tag = tagopt) m =
    inline-fil ++
      embed-block-breakable ctx (math-scheme ctx tagopt m)
        ++ omit-skip-after


  val block ctx +math-list mlst =
    let mingap = get-font-size ctx *' 2. in
    let ib-fil =
      discretionary 100 (inline-skip mingap ++ inline-fil) inline-fil inline-fil
    in
    let ib =
      mlst |> List.fold-left-adjacent (fun ibacc m _ optnext -> (
        let ib-after =
          match optnext with
          | None    -> inline-fil
          | Some(_) -> ib-fil
          end
        in
          ibacc ++ embed-math ctx m ++ ib-after
      )) inline-fil
    in
    let margin = get-font-size ctx *' margin-ratio in
    let ctx =
      ctx |> set-min-gap-of-lines 12pt
          |> set-paragraph-margin margin margin
    in
      line-break true true ctx ib


  val inline ctx \math-list mlst =
    inline-fil ++
      embed-block-breakable ctx (read-block ctx '<+math-list(mlst);>)
        ++ omit-skip-after


  val block ctx +align mlstlst =
    let vlen = 4pt in
    let lengap = get-font-size ctx *' 2. in
    let celllstlst =
      mlstlst |> List.map (fun mlst -> (
        mlst |> List.mapi-adjacent (fun index m _ mnextopt -> (
          let ibm = embed-math ctx m in
          let ib =
            match mnextopt with
            | None ->
                ibm

            | Some(mnext) ->
                let ibspaceopt = space-between-maths ctx m mnext in
                match ibspaceopt with
                | None          -> ibm
                | Some(ibspace) -> ibm ++ ibspace
                end
            end
          in
          let ib =
            if index mod 2 == 0 then
              inline-fil ++ ib
            else
              match mnextopt with
              | None    -> ib ++ inline-fil
              | Some(_) -> ib ++ inline-fil ++ inline-skip lengap
              end
          in
            NormalCell((0pt, 0pt, vlen, vlen), ib)
        ))
      ))
    in
    let margin = get-font-size ctx *' margin-ratio in
      line-break true true (ctx |> set-paragraph-margin margin margin)
        (inline-fil ++ (tabular celllstlst (fun _ _ -> [])) ++ inline-fil)
        % temporary


  val inline ctx \align mlstlst =
    inline-fil ++
      embed-block-breakable ctx (read-block ctx '<+align(mlstlst);>)
        ++ omit-skip-after


  val math-list lst =
    lst |> List.fold-left math-concat (math-char MathOrd ` `)


  val single cp = string-unexplode [cp]


  val greek-lowercase cp cpb =
    let s = single cp in
    let sb = single cpb in
      math-variant-char MathOrd (|
        italic        = s,
        bold-italic   = sb,
        roman         = s,
        bold-roman    = sb,
        script        = s,
        bold-script   = sb,
        fraktur       = s,
        bold-fraktur  = sb,
        double-struck = s,
      |)


  val greek-uppercase cp cpb cpr cprb =
    let s = single cp in
    let sb = single cpb in
    let sr = single cpr in
    let srb = single cprb in
      math-variant-char MathOrd (|
        italic        = s,
        bold-italic   = sb,
        roman         = sr,
        bold-roman    = srb,
        script        = s,
        bold-script   = sb,
        fraktur       = s,
        bold-fraktur  = sb,
        double-struck = s,
      |)

  val math \alpha    = greek-lowercase 0x1D6FC 0x1D736
  val math \beta     = greek-lowercase 0x1D6FD 0x1D737
  val math \gamma    = greek-lowercase 0x1D6FE 0x1D738
  val math \delta    = greek-lowercase 0x1D6FF 0x1D739
  val math \epsilon  = greek-lowercase 0x1D700 0x1D73A
  val math \zeta     = greek-lowercase 0x1D701 0x1D73B
  val math \eta      = greek-lowercase 0x1D702 0x1D73C
  val math \theta    = greek-lowercase 0x1D703 0x1D73D
  val math \iota     = greek-lowercase 0x1D704 0x1D73E
  val math \kappa    = greek-lowercase 0x1D705 0x1D73F
  val math \lambda   = greek-lowercase 0x1D706 0x1D740
  val math \mu       = greek-lowercase 0x1D707 0x1D741
  val math \nu       = greek-lowercase 0x1D708 0x1D742
  val math \xi       = greek-lowercase 0x1D709 0x1D743
  val math \omicron  = greek-lowercase 0x1D70A 0x1D744
  val math \pi       = greek-lowercase 0x1D70B 0x1D745
  val math \rho      = greek-lowercase 0x1D70C 0x1D746
  val math \sigma    = greek-lowercase 0x1D70E 0x1D748
  val math \tau      = greek-lowercase 0x1D70F 0x1D749
  val math \upsilon  = greek-lowercase 0x1D710 0x1D74A
  val math \phi      = greek-lowercase 0x1D711 0x1D74B
  val math \chi      = greek-lowercase 0x1D712 0x1D74C
  val math \psi      = greek-lowercase 0x1D713 0x1D74D
  val math \omega    = greek-lowercase 0x1D714 0x1D74E

  val math \Alpha    = greek-uppercase 0x1D6E2 0x1D71C 0x0391 0x1D6A8
  val math \Beta     = greek-uppercase 0x1D6E3 0x1D71D 0x0392 0x1D6A9
  val math \Gamma    = greek-uppercase 0x1D6E4 0x1D71E 0x0393 0x1D6AA
  val math \Delta    = greek-uppercase 0x1D6E5 0x1D71F 0x0394 0x1D6AB
  val math \Epsilon  = greek-uppercase 0x1D6E6 0x1D720 0x0395 0x1D6AC
  val math \Zeta     = greek-uppercase 0x1D6E7 0x1D721 0x0396 0x1D6AD
  val math \Eta      = greek-uppercase 0x1D6E8 0x1D722 0x0397 0x1D6AE
  val math \Theta    = greek-uppercase 0x1D6E9 0x1D723 0x0398 0x1D6AF
  val math \Iota     = greek-uppercase 0x1D6EA 0x1D724 0x0399 0x1D6B0
  val math \Kappa    = greek-uppercase 0x1D6EB 0x1D725 0x039A 0x1D6B1
  val math \Lambda   = greek-uppercase 0x1D6EC 0x1D726 0x039B 0x1D6B2
  val math \Mu       = greek-uppercase 0x1D6ED 0x1D727 0x039C 0x1D6B3
  val math \Nu       = greek-uppercase 0x1D6EE 0x1D728 0x039D 0x1D6B4
  val math \Xi       = greek-uppercase 0x1D6EF 0x1D729 0x039E 0x1D6B5
  val math \Omicron  = greek-uppercase 0x1D6F0 0x1D72A 0x039F 0x1D6B6
  val math \Pi       = greek-uppercase 0x1D6F1 0x1D72B 0x03A0 0x1D6B7
  val math \Rho      = greek-uppercase 0x1D6F2 0x1D72C 0x03A1 0x1D6B8
  val math \Sigma    = greek-uppercase 0x1D6F4 0x1D72E 0x03A3 0x1D6BA
  val math \Tau      = greek-uppercase 0x1D6F5 0x1D72F 0x03A4 0x1D6BB
  val math \Upsilon  = greek-uppercase 0x1D6F6 0x1D730 0x03A5 0x1D6BC
  val math \Phi      = greek-uppercase 0x1D6F7 0x1D731 0x03A6 0x1D6BD
  val math \Chi      = greek-uppercase 0x1D6F8 0x1D732 0x03A7 0x1D6BE
  val math \Psi      = greek-uppercase 0x1D6F9 0x1D733 0x03A8 0x1D6BF
  val math \Omega    = greek-uppercase 0x1D6FA 0x1D734 0x03A9 0x1D6C0

  val ord = math-char MathOrd
  val bin = math-char MathBin
  val rel = math-char MathRel
  val op = math-char MathOp
  val punct = math-char MathPunct
  val prefix = math-char MathPrefix

  val vop-scheme charf s =
    let mop = charf MathOp s in
      math-pull-in-scripts MathOp MathOp
        (fun moptS moptT -> (
          let m =
            match moptS with
            | None     -> mop
            | Some(mS) -> math-lower mop mS
            end
          in
            match moptT with
            | None     -> m
            | Some(mT) -> math-upper m mT
            end
        ))

  val bigop = vop-scheme math-big-char
  val vop = vop-scheme math-char

  val math \to    = rel `→`
  val math \pm    = bin `±`
  val math \mp    = bin `∓`
  val math \times = bin `×`
  val math \setminus = bin `∖`
  val math \ast = bin `∗`
  val math \circ = bin `∘`
  val math \bullet = bin `∙`
  val math \cap = bin `∩`
  val math \cup = bin `∪`
  val math \uplus = bin `⊎`
  val math \sqcap = bin `⊓`
  val math \sqcup = bin `⊔`
  val math \wedge = bin `∧`
  val math \vee   = bin `∨`
  val math \oplus = bin `⊕`
  val math \ominus = bin `⊖`
  val math \otimes = bin `⊗`
  val math \oslash = bin `⊘`

  val math \vdash = rel `⊢`
  val math \nvdash = rel `⊬`
  val math \dashv = rel `⊣`
  val math \vDash = rel `⊨`
  val math \nvDash = rel `⊭`
  val math \Vdash = rel `⊩`
  val math \nVdash = rel `⊮`

  val math \colon-rel = rel `:`

  val math \leq = rel `≤`
  val math \geq = rel `≥`
  val math \equiv = rel `≡`
  val math \nequiv = rel `≢`
  val math \neq = rel `≠`
  val math \sim = rel `∼`
  val math \nsim = rel `≁`
  val math \simeq = rel `≃`
  val math \nsimeq = rel `≄`
  val math \propto = rel `∝`
  val math \coloneq = rel `≔`
  val math \eqcolon = rel `≕`

  val math \in = rel `∈`
  val math \nin = rel `∉`
  val math \ni = rel `∋`
  val math \nni = rel `∌`
  val math \subset = rel `⊂`
  val math \supset = rel `⊃`
  val math \nsubset = rel `⊄`
  val math \nsupset = rel `⊅`
  val math \subseteq = rel `⊆`
  val math \supseteq = rel `⊇`
  val math \nsubseteq = rel `⊈`
  val math \nsupseteq = rel `⊉`
  val math \subsetneq = rel `⊊`
  val math \supsetneq = rel `⊋`
  val math \sqsubset = rel `⊏`
  val math \sqsupset = rel `⊐`
  val math \sqsubseteq = rel `⊑`
  val math \sqsupseteq = rel `⊒`
  val math \nsqsubseteq = rel `⋢`
  val math \nsqsupseteq = rel `⋣`
  val math \sqsubsetneq = rel `⋤`
  val math \sqsupsetneq = rel `⋥`
  val math \prec = rel `≺`
  val math \succ = rel`≻`
  val math \nprec = rel `⊀`
  val math \nsucc = rel `⊁`
  val math \preccurlyeq = rel`≼`
  val math \succcurlyeq = rel `≽`
  val math \precsim = rel `≾`
  val math \succsim = rel `≿`
  val math \npreccurlyeq = rel `⋠`
  val math \nsucccurlyeq = rel `⋡`

  val math \emptyset = ord `∅`
  val math \infty = ord `∞`
  val math \top = ord `⊤`
  val math \bot = ord `⊥`
  val math \therefore = ord `∴`
  val math \because = ord `∵`
  val math \forall = ord `∀`
  val math \exists = ord `∃`
  val math \nexists = ord `∄`
  val math \bigcirc = ord `◯`

  val math \cdot  = bin `⋅`
  val math \ldots = ord `…`
  val math \cdots = math-char MathInner `⋯`
  val math \vdots = ord `⋮`
  val math \ddots = ord `⋱`
  val math \backddots = ord `⋰`

  val math \lim = vop `lim`
  val math \colim = vop `colim`
  val math \max = vop `max`
  val math \min = vop `min`
  val math \inf = vop `inf`
  val math \sup = vop `sup`
  val math \sin = op `sin`
  val math \cos = op `cos`
  val math \tan = op `tan`
  val math \cot = op `cot`
  val math \sec = op `sec`
  val math \csc = op `csc`
  val math \log = op `log`
  val math \tr  = op `tr`
  val math \det = op `det`
  val math \dom = op `dom`
  val math \cod = op `cod`
  val math \Ker = op `Ker`
  val math \Im = op `Im`

  val math \sum = bigop `∑`
  val math \prod = bigop `∏`
  val math \coprod = bigop `∐`
  val math \bigwedge = bigop `⋀`
  val math \bigvee = bigop `⋁`
  val math \bigcap = bigop `⋂`
  val math \bigcup = bigop `⋃`

  val math \lnot = ord `¬`
  val math \land = rel `∧`
  val math \lor  = rel `∨`

  val math \Leftarrow = rel `⇐`
  val math \Rightarrow = rel `⇒`
  val math \Leftrightarrow = rel `⇔`
  val math \Uparrow = rel `⇑`
  val math \Downarrow = rel `⇓`
  val math \Updownarrow = rel `⇕`
  val math \nRightarrow = rel `⇍`
  val math \nLeftarrow = rel `⇏`
  val math \nLeftrightarrow = rel `⇎`
  val math \leftarrow = rel `←`
  val math \rightarrow = rel `→`
  val math \uparrow = rel `↑`
  val math \downarrow = rel `↓`
  val math \updownarrow = rel `↕`
  val math \nwarrow = rel `↖`
  val math \nearrow = rel `↗`
  val math \searrow = rel `↘`
  val math \swarrow = rel `↙`
  val math \nleftarrow = rel `↚`
  val math \nrightarrow = rel `↛`
  val math \nleftrightarrow = rel `↮`
  val math \mapsto = rel `↦`
  val math \hookleftarrow = rel `↩`
  val math \hookrightarrow = rel `↪`
  val math \rightarrowtail = rel `↣`
  val math \leftarrowtail = rel `↢`
  val math \twoheadleftarrow = rel `↞`
  val math \twoheadrightarrow = rel `↠`
  val math \twoheaduparrow = rel `↟`
  val math \twoheaddownarrow = rel `↡`
  val math \leftharpoonup = rel `↼`
  val math \leftharpoondown = rel `↽`
  val math \rightharpoonup = rel `⇀`
  val math \rightharpoondown = rel `⇁`
  val math \rightleftharpoons = rel `⇌`
  val math \upharpoonright = rel `↾`
  val math \upharpoonleft = rel `↿`
  val math \downharpoonright = rel `⇂`
  val math \downharpoonleft = rel `⇃`
  val math \longleftarrow = rel `⟵`
  val math \longrightarrow = rel `⟶`
  val math \longleftrightarrow = rel `⟷`
  val math \Longleftarrow = rel `⟸`
  val math \Longrightarrow = rel `⟹`
  val math \Longleftrightarrow = rel `⟺`
  val math \circlearrowleft = rel `↺`
  val math \circlearrowright = rel `↻`

  val math \between = rel `≬`
  val math \pitchfork = rel `⋔`
  val math \intercal = rel `⊺`
  val math \ll = rel `≪`
  val math \gg = rel `≫`
  val math \lll = rel `⋘`
  val math \ggg = rel `⋙`
  val math \leqq = rel `≦`
  val math \geqq = rel `≧`
  val math \lneqq = rel `≨`
  val math \gneqq = rel `≩`
  val math \lnsim = rel `⋦`
  val math \gnsim = rel `⋧`
  val math \precnsim = rel `⋨`
  val math \succnsim = rel `⋩`
  val math \Subset = rel `⋐`
  val math \Supset = rel `⋑`
  val math \Cap = bin `⋒`
  val math \Cup = bin `⋓`
  val math \lhd = rel `⊲`
  val math \rhd = rel `⊳`
  val math \unlhd = rel `⊴`
  val math \unrhd = rel `⊵`
  val math \triangleleft = rel `⊲`
  val math \triangleright = rel `⊳`
  val math \trianglelefteq = rel `⊴`
  val math \trianglerighteq = rel `⊵`
  val math \backsim = rel `∽`
  val math \backsimeq = rel `⋍`
  val math \eqcirc = rel `≖`
  val math \cong = rel `≅`
  val math \simneq = rel `≆`
  val math \ncong = rel `≇`
  val math \approx = rel `≈`
  val math \napprox = rel `≉`
  val math \approxeq = rel `≊`
  val math \curlyeqprec = rel `⋞`
  val math \curlyeqsucc = rel `⋟`
  val math \lessdot = rel `⋖`
  val math \gtrdot = rel `⋗`
  val math \lesssim = rel `≲`
  val math \gtrsim = rel `≳`
  val math \nlesssim = rel `≴`
  val math \ngtrsim = rel `≵`
  val math \lessgtr = rel `≶`
  val math \gtrless = rel `≷`
  val math \nlessgtr = rel `≸`
  val math \ngtrless = rel `≹`
  val math \ntriangleleft = rel `⋪`
  val math \ntriangleright = rel `⋫`
  val math \ntrianglelefteq = rel `⋬`
  val math \ntrianglerighteq = rel `⋭`
  val math \lesseqgtr = rel `⋚`
  val math \gtreqless = rel `⋛`
  val math \nless = rel `≮`
  val math \ngtr = rel `≯`
  val math \nleq = rel `≰`
  val math \ngeq = rel `≱`
  val math \asymp = rel `≍`
  val math \nasymp = rel `≭`
  val math \circeq = rel `≗`
  val math \Bumpeq = rel `≎`
  val math \bumpeq = rel `≏`
  val math \doteq = rel `≐`
  val math \doteqdot = rel `≑`
  val math \fallingdotseq = rel `≒`
  val math \risingdotseq = rel `≓`
  val math \mid = rel `∣`
  val math \nmid = rel `∤`
  val math \parallel = rel `∥`
  val math \nparallel = rel `∦`
  val math \Vvdash = rel `⊪`
  val math \VDash = rel `⊫`
  val math \coloncoloneq = rel `⩴`
  val math \leqslant = rel `⩽`
  val math \geqslant = rel `⩾`
  val math \dashV = rel `⫣`
  val math \Dashv = rel `⫤`
  val math \DashV = rel `⫥`
  val math \preceq = rel `⪯`
  val math \succeq = rel `⪰`

  val math \amalg = bin `⨿`
  val math \dotplus = bin `∔`
  val math \divideontimes = bin `⋇`
  val math \odot = bin `⊙`
  val math \circledcirc = bin `⊚`
  val math \circledast = bin `⊛`
%  val math \circledeq = bin `⊜`
  val math \circleddash = bin `⊝`
  val math \boxplus = bin `⊞`
  val math \boxminus = bin `⊟`
  val math \boxtimes = bin `⊠`
  val math \boxdot = bin `⊡`
  val math \curlyvee = bin `⋎`
  val math \curlywedge = bin `⋏`
  val math \Join = bin `⋈`
  val math \ltimes = bin `⋉`
  val math \rtimes = bin `⋊`
  val math \leftthreetimes = bin `⋋`
  val math \rightthreetimes = bin `⋌`
  val math \wr = bin `≀`

  val math \diamond = ord `⋄`
  val math \star = ord `⋆`
  val math \complement = ord `∁`
  val math \angle = ord `∠`
  val math \measuredangle = ord `∡`
  val math \sphericalangle = rel `∢`

  val math \ordd = prefix `d`
  val math \partial = prefix `∂`
  val math \nabla  = prefix `∇`

%% -- for Latin Modern Math --
  val math \int =
    let kernfL _ _ = 0pt in
    let kernfR fontsize ypos = fontsize *' 0.45 in
      math-big-char-with-kern MathOp `∫` kernfL kernfR

%% -- for Cambria Math --
%  val math \int =
%    let kernfL _ _ = 0pt in
%    let kernfR fontsize ypos = fontsize *' 0.2 in
%      math-big-char-with-kern MathOp `∫` kernfL kernfR

  val math-space =
    text-in-math MathOrd (fun ctx -> inline-skip 30pt)

  val math \and-also = math-space

  val math \tyjd tyenv tm ty =
    ${#tyenv \vdash #tm \colon-rel #ty}

  val math \synteq = ${\equiv}

  val math \dot-punct =
    math-char MathPunct `.`

  val math \tmabstyped var ty body =
    ${\lambda #var \colon-rel #ty \dot-punct #body}

  val math \npe =
    math-color (RGB(1., 0., 0.)) (math-char-class MathRoman ${e})

  val math \bi m =
    math-char-class MathBoldItalic m

  type paren = Pervasives.paren %TODO (enhance): remove this

  val half-length hgt dpt hgtaxis fontsize =
    let minhalflen = fontsize *' 0.5 in
    let lenappend = fontsize *' 0.1 in
      Pervasives.length-max minhalflen ((Pervasives.length-max (hgt -' hgtaxis) (hgtaxis +' dpt)) +' lenappend)

  val angle-left thk hgt dpt hgtaxis fontsize color =
    let halflen = half-length hgt dpt hgtaxis fontsize in
    let widparen = halflen *' 0.375 in
    let wid = widparen +' fontsize *' 0.1 in
    let path (xpos, ypos) =
      start-path (xpos +' wid, ypos +' hgtaxis +' halflen)
        |> line-to (xpos +' wid -' widparen, ypos +' hgtaxis)
        |> line-to (xpos +' wid, ypos +' hgtaxis -' halflen)
        |> terminate-path
    in
    let graphics point = stroke thk color (path point) in
    let kerninfo y =
      let widkern = widparen in
      let r = 0. in
      let gap = Pervasives.length-abs (y -' hgtaxis) in
        if halflen *' r <' gap then
          widkern *' ((gap -' halflen *' r) /' (halflen *' (1. -. r)))
        else
          0pt
    in
    (inline-graphics wid (hgtaxis +' halflen) (halflen -' hgtaxis) graphics, kerninfo)

  val angle-right thk hgt dpt hgtaxis fontsize color =
    let halflen = half-length hgt dpt hgtaxis fontsize in
    let widparen = halflen *' 0.375 in
    let wid = widparen +' fontsize *' 0.1 in
    let path (xpos, ypos) =
      start-path (xpos, ypos +' hgtaxis +' halflen)
        |> line-to (xpos +' widparen, ypos +' hgtaxis)
        |> line-to (xpos, ypos +' hgtaxis -' halflen)
        |> terminate-path
    in
    let graphics point = stroke thk color (path point) in
    let kerninfo y =
      let widkern = widparen in
      let r = 0. in
      let gap = Pervasives.length-abs (y -' hgtaxis) in
        if halflen *' r <' gap then
          widkern *' ((gap -' halflen *' r) /' (halflen *' (1. -. r)))
        else
          0pt
    in
      (inline-graphics wid (hgtaxis +' halflen) (halflen -' hgtaxis) graphics, kerninfo)

  val math \angle-bracket =
    math-paren (angle-left 0.5pt) (angle-right 0.5pt)

  val paren-left hgt dpt hgtaxis fontsize color =
    let halflen = half-length hgt dpt hgtaxis fontsize in
    let w0 = fontsize *' 0.1 in
    let w1 = fontsize *' 0.075 +' halflen *' 0.01 in
    let w2 = halflen *' 0.25 in %temporary
    let w-extra = fontsize *' 0.1 in
    let t1 = fontsize *' 0.025 in
    let t2 = fontsize *' 0.025 in

    let qA = halflen *' 0.35 in
    let p1 = (w1 +' w2) *' 0.75 in
    let q1 = halflen *' 0.3 in

    let qB = halflen *' 0.45 in
    let p2 = w2 *' 0.5 in
    let q2 = halflen *' 0.2 in

    let path (xpos, ypos) =
      let ycenter = ypos +' hgtaxis in
      let x0 = xpos +' w0 in
      let x1 = x0 +' w1 in
      let x2 = x1 +' w2 in
      start-path (x2, ycenter +' halflen)
        |> bezier-to (x2 -' p1, ycenter +' halflen -' q1) (x0, ycenter +' qA) (x0, ycenter)
        |> bezier-to (x0, ycenter -' qA) (x2 -' p1, ycenter -' halflen +' q1) (x2, ycenter -' halflen)
        |> line-to (x2 +' t1, ycenter -' halflen +' t2)
        |> bezier-to (x2 -' p2, ycenter -' halflen +' q2) (x1, ycenter -' qB) (x1, ycenter)
        |> bezier-to (x1, ycenter +' qB) (x2 -' p2, ycenter +' halflen -' q2) (x2 +' t1, ycenter +' halflen -' t2)
        |> close-with-line
    in
    let graphics point = fill color (path point) in
    let kerninfo _ = 0pt in
      (inline-graphics (w0 +' w1 +' w2 +' w-extra) (hgtaxis +' halflen) (halflen -' hgtaxis) graphics, kerninfo)

  val paren-right hgt dpt hgtaxis fontsize color =
    let halflen = half-length hgt dpt hgtaxis fontsize in
    let w0 = fontsize *' 0.1 in
    let w1 = fontsize *' 0.075 +' halflen *' 0.01 in
    let w2 = halflen *' 0.25 in %temporary
    let w-extra = fontsize *' 0.1 in
    let t1 = 0pt -' fontsize *' 0.025 in
    let t2 = fontsize *' 0.025 in

    let qA = halflen *' 0.35 in
    let p1 = 0pt -' (w1 +' w2) *' 0.75 in
    let q1 = halflen *' 0.3 in

    let qB = halflen *' 0.45 in
    let p2 = 0pt -' w2 *' 0.5 in
    let q2 = halflen *' 0.2 in

    let path (xpos, ypos) =
      let ycenter = ypos +' hgtaxis in
      let x0 = xpos +' w-extra +' w2 +' w1 in
      let x1 = xpos +' w-extra +' w2 in
      let x2 = xpos +' w-extra in
      start-path (x2, ycenter +' halflen)
        |> bezier-to (x2 -' p1, ycenter +' halflen -' q1) (x0, ycenter +' qA) (x0, ycenter)
        |> bezier-to (x0, ycenter -' qA) (x2 -' p1, ycenter -' halflen +' q1) (x2, ycenter -' halflen)
        |> line-to (x2 +' t1, ycenter -' halflen +' t2)
        |> bezier-to (x2 -' p2, ycenter -' halflen +' q2) (x1, ycenter -' qB) (x1, ycenter)
        |> bezier-to (x1, ycenter +' qB) (x2 -' p2, ycenter +' halflen -' q2) (x2 +' t1, ycenter +' halflen -' t2)
        |> close-with-line
    in
    let graphics point = fill color (path point) in
    let widparen = w0 +' w1 +' w2 +' w-extra in
    let kerninfo y =
      let widkern = widparen *' 0.5 in
      let r = 0.25 in
      let gap = Pervasives.length-abs (y -' hgtaxis) in
        let diff = Pervasives.length-min (gap -' halflen *' r) (halflen *' (1. -. r)) in
        if 0pt <' diff then
          widkern *' (diff /' (halflen *' (1. -. r)))
        else
          0pt
    in
    (inline-graphics widparen (hgtaxis +' halflen) (halflen -' hgtaxis) graphics, kerninfo)


  val math \paren =
    math-paren paren-left paren-right


  val math \app m1 m2 = ${#m1 \paren{#m2}}


  val brace-left hgt dpt hgtaxis fontsize color =

    let t0 = fontsize *' 0.0125 in
    let t4 = fontsize *' 0.025 in

    let halflen = half-length hgt dpt hgtaxis fontsize in
    let h-straight =  halflen *' 0.9 -' fontsize *' 0.3 in
    let w-straight = h-straight *' 0.15 in
    let w1 = fontsize *' 0.0125 in
    let w2 = fontsize *' 0.02 in
    let w5 = fontsize *' 0.01 in
    let w6 = fontsize *' 0.015 in
    let w-extra = fontsize *' 0.1 in

    let x0 = fontsize *' 0.125 in
    let x1 = fontsize *' 0.25 in
    let x2 = x1 -' w-straight in
    let x3 = x2 +' fontsize *' 0.2 in
    let x4 = x3 +' fontsize *' 0.01 in
    let x5 = x2 +' fontsize *' 0.0625 in
    let x6 = x5 +' w-straight in
    let x7 = fontsize *' 0.225 in

    let p0 = fontsize *' 0.2 in
    let p1 = x1 +' w1 in
    let p2 = x2 -' w2 in
    let p3 = x3 -' fontsize *' 0.1 in
    let p4 = x4 -' fontsize *' 0.09 in
    let p5 = x5 -' w5 in
    let p6 = x6 +' w6 in
    let p7 = fontsize *' 0.3 in

    let y0 = t0 in
    let y1 = fontsize *' 0.125 in
    let y2 = y1 +' h-straight in
    let y3 = halflen in
    let y4 = halflen -' t4 in
    let y5 = halflen -' fontsize *' 0.175 in
    let y6 = y5 -' h-straight in
    let y7 = 0pt in

    let q0 = y0 in
    let q1 = y1 -' (y2 -' y1) *' ((x1 -' p1) /' (x2 -' x1)) in
    let q2 = y2 +' (y2 -' y1) *' ((p2 -' x2) /' (x2 -' x1)) in
    let q3 = halflen -' fontsize *' 0.00875 in
    let q4 = halflen -' t4 -' fontsize *' 0.01 in
    let q5 = y5 +' (y5 -' y6) *' ((p5 -' x5) /' (x5 -' x6)) in
    let q6 = y6 -' (y5 -' y6) *' ((x6 -' p6) /' (x5 -' x6)) in
    let q7 = fontsize *' 0.025 in

    let path (xpos, ypos) =
      let ycenter = ypos +' hgtaxis in
      let fP (x, y) = (xpos +' x, ycenter +' y) in
      let fN (x, y) = (xpos +' x, ycenter -' y) in
        start-path   (fP (x0, y0))
          |> bezier-to (fP (p0, q0)) (fP (p1, q1)) (fP (x1, y1))
          |> line-to (fP (x2, y2))
          |> bezier-to (fP (p2, q2)) (fP (p3, q3)) (fP (x3, y3))
          |> line-to (fP (x4, y4))
          |> bezier-to (fP (p4, q4)) (fP (p5, q5)) (fP (x5, y5))
          |> line-to (fP (x6, y6))
          |> bezier-to (fP (p6, q6)) (fP (p7, q7)) (fP (x7, y7))
          |> bezier-to (fN (p7, q7)) (fN (p6, q6)) (fN (x6, y6))
          |> line-to (fN (x5, y5))
          |> bezier-to (fN (p5, q5)) (fN (p4, q4)) (fN (x4, y4))
          |> line-to (fN (x3, y3))
          |> bezier-to (fN (p3, q3)) (fN (p2, q2)) (fN (x2, y2))
          |> line-to (fN (x1, y1))
          |> bezier-to (fN (p1, q1)) (fN (p0, q0)) (fN (x0, y0))
          |> close-with-line
    in
    let graphics point = fill color (path point) in
    let kerninfo _ = 0pt in
    (inline-graphics (x4 +' w-extra) (hgtaxis +' halflen) (halflen -' hgtaxis) graphics, kerninfo)


  val brace-right hgt dpt hgtaxis fontsize color =

    let t0 = fontsize *' 0.0125 in
    let t4 = fontsize *' 0.025 in

    let halflen = half-length hgt dpt hgtaxis fontsize in
    let h-straight =  halflen *' 0.9 -' fontsize *' 0.3 in
    let w-straight = h-straight *' 0.15 in
    let w1 = fontsize *' 0.0125 in
    let w2 = fontsize *' 0.02 in
    let w5 = fontsize *' 0.01 in
    let w6 = fontsize *' 0.015 in
    let w-extra = fontsize *' 0.1 in

    let x0 = w-extra +' fontsize *' 0.125 in
    let x1 = w-extra +' fontsize *' 0.25 in
    let x2 = x1 -' w-straight in
    let x3 = x2 +' fontsize *' 0.2 in
    let x4 = x3 +' fontsize *' 0.01 in
    let x5 = x2 +' fontsize *' 0.0625 in
    let x6 = x5 +' w-straight in
    let x7 = w-extra +' fontsize *' 0.225 in

    let p0 = w-extra +' fontsize *' 0.2 in
    let p1 = x1 +' w1 in
    let p2 = x2 -' w2 in
    let p3 = x3 -' fontsize *' 0.1 in
    let p4 = x4 -' fontsize *' 0.09 in
    let p5 = x5 -' w5 in
    let p6 = x6 +' w6 in
    let p7 = w-extra +' fontsize *' 0.3 in

    let y0 = t0 in
    let y1 = fontsize *' 0.125 in
    let y2 = y1 +' h-straight in
    let y3 = halflen in
    let y4 = halflen -' t4 in
    let y5 = halflen -' fontsize *' 0.175 in
    let y6 = y5 -' h-straight in
    let y7 = 0pt in

    let q0 = y0 in
    let q1 = y1 -' (y2 -' y1) *' ((x1 -' p1) /' (x2 -' x1)) in
    let q2 = y2 +' (y2 -' y1) *' ((p2 -' x2) /' (x2 -' x1)) in
    let q3 = halflen -' fontsize *' 0.00875 in
    let q4 = halflen -' t4 -' fontsize *' 0.01 in
    let q5 = y5 +' (y5 -' y6) *' ((p5 -' x5) /' (x5 -' x6)) in
    let q6 = y6 -' (y5 -' y6) *' ((x6 -' p6) /' (x5 -' x6)) in
    let q7 = fontsize *' 0.025 in

    let path (xpos, ypos) =
      let ycenter = ypos +' hgtaxis in
      let fP (x, y) = (xpos +' x4 -' x +' w-extra, ycenter +' y) in
      let fN (x, y) = (xpos +' x4 -' x +' w-extra, ycenter -' y) in
        start-path   (fP (x0, y0))
          |> bezier-to (fP (p0, q0)) (fP (p1, q1)) (fP (x1, y1))
          |> line-to (fP (x2, y2))
          |> bezier-to (fP (p2, q2)) (fP (p3, q3)) (fP (x3, y3))
          |> line-to (fP (x4, y4))
          |> bezier-to (fP (p4, q4)) (fP (p5, q5)) (fP (x5, y5))
          |> line-to (fP (x6, y6))
          |> bezier-to (fP (p6, q6)) (fP (p7, q7)) (fP (x7, y7))
          |> bezier-to (fN (p7, q7)) (fN (p6, q6)) (fN (x6, y6))
          |> line-to (fN (x5, y5))
          |> bezier-to (fN (p5, q5)) (fN (p4, q4)) (fN (x4, y4))
          |> line-to (fN (x3, y3))
          |> bezier-to (fN (p3, q3)) (fN (p2, q2)) (fN (x2, y2))
          |> line-to (fN (x1, y1))
          |> bezier-to (fN (p1, q1)) (fN (p0, q0)) (fN (x0, y0))
          |> close-with-line
    in
    let graphics point = fill color (path point) in
    let kerninfo _ = 0pt in
    (inline-graphics x4 (hgtaxis +' halflen) (halflen -' hgtaxis) graphics, kerninfo)


  val brace-left-long hgt dpt hgtaxis fontsize color =
    let halflen = half-length hgt dpt hgtaxis fontsize in

    let t0B = fontsize *' 0.05 in
    let t1A = fontsize *' 0.05 in
    let t1B = fontsize *' 0.025 in
    let t2A = halflen *' 0.1 in
    let t2B = halflen *' 0.15 in
    let t3A = fontsize *' 0.05 in

    let (x0, y0) = (fontsize *' 0.005, fontsize *' 0.005) in
    let (p0B, q0B) = (x0 +' t0B, y0) in

    let (x1, y1) = (fontsize *' 0.2, fontsize *' 0.2) in
    let (p1A, q1A) = (x1, y1 -' t1A) in
    let (p1B, q1B) = (x1, y1 +' t1B) in

    let theta = atan2 (x1 /' 1pt) (halflen /' 1pt) in

    let (x2, y2) = (fontsize *' 0.175, halflen *' 0.5) in

    let (p2A, q2A) = (x2 +' t2A *' (sin theta), y2 -' t2A *' (cos theta)) in
    let (p2B, q2B) = (x2 -' t2B *' (sin theta), y2 +' t2B *' (cos theta)) in

    let (x3, y3) = (fontsize *' 0.15, halflen -' fontsize *' 0.2) in

    let (p3A, q3A) = (x3, y3 -' t3A) in

    let path (xpos, ypos) =
      let ycenter = ypos +' hgtaxis in
      let fP (x, y) = (xpos +' x, ycenter +' y) in
      let fN (x, y) = (xpos +' x, ycenter -' y) in
%        start-path (fP (x0, y0))
%          |> bezier-to (fP (p0B, q0B)) (fP (p1A, q1A)) (fP (x1, y1))
%          |> bezier-to (fP (p1B, q1B)) (fP (p2A, q2A)) (fP (x2, y2))
%          |> close-with-line
        Gr.poly-line (fP (x0, y0)) [
          fP (p0B, q0B), fP (p1A, q1A), fP (x1, y1),
          fP (p1B, q1B), fP (p2A, q2A), fP (x2, y2),
          fP (p2B, q2B), fP (p3A, q3A), fP (x3, y3),
        ]
    in
    let graphics point = fill color (path point) in
    let kerninfo _ = 0pt in
    (inline-graphics (x2) (hgtaxis +' halflen) (halflen -' hgtaxis) graphics, kerninfo)


  val math \brace =
    math-paren brace-left brace-right


  val bar-middle hgt dpt hgtaxis fontsize color =
    let halflen = half-length hgt dpt hgtaxis fontsize in
    let halfwid = fontsize *' 0.5 in
    let graphics (x, y) =
      stroke 0.5pt color
        (Gr.line (x +' halfwid, y +' hgtaxis -' halflen) (x +' halfwid, y +' hgtaxis +' halflen))
    in
    let kerninfo _ = 0pt in
    (inline-graphics (halfwid *' 2.) (hgtaxis +' halflen) (halflen -' hgtaxis) graphics, kerninfo)


  val math \setsep m1 m2 =
    math-paren-with-middle brace-left brace-right bar-middle [m1, m2]


  val slash-middle hgt dpt hgtaxis fontsize color =
    let halflen = half-length hgt dpt hgtaxis fontsize in
    let halfwid = halflen *' 0.5 in
    let graphics (x, y) =
      stroke 0.5pt color
        (Gr.line (x, y +' hgtaxis -' halflen) (x +' halfwid *' 2., y +' hgtaxis +' halflen))
    in
    let kerninfo _ = 0pt in
    (inline-graphics (halfwid *' 2.) (hgtaxis +' halflen) (halflen -' hgtaxis) graphics, kerninfo)


  val bracket-metrics fontsize halflen =
    let w0 = fontsize *' 0.1 in
    let w1 = fontsize *' 0.05 +' halflen *' 0.005 in
    let w2 = halflen *' 0.3 in
    let t = fontsize *' 0.03 in
      (w0, w1, w2, t)


  val bracket-path x0 x1 x2 t ypos hgtaxis halflen =
    let ytop = ypos +' hgtaxis +' halflen in
    let ybot = ypos +' hgtaxis -' halflen in
      start-path (x2, ytop)
        |> line-to (x0, ytop)
        |> line-to (x0, ybot)
        |> line-to (x2, ybot)
        |> line-to (x2, ybot +' t)
        |> line-to (x1, ybot +' t)
        |> line-to (x1, ytop -' t)
        |> line-to (x2, ytop -' t)
        |> close-with-line


  val floor-path x0 x1 x2 t ypos hgtaxis halflen =
    let ytop = ypos +' hgtaxis +' halflen in
    let ybot = ypos +' hgtaxis -' halflen in
      start-path (x0, ytop)
        |> line-to (x0, ybot)
        |> line-to (x2, ybot)
        |> line-to (x2, ybot +' t)
        |> line-to (x1, ybot +' t)
        |> line-to (x1, ytop)
        |> close-with-line


  val ceil-path x0 x1 x2 t ypos hgtaxis halflen =
    let ytop = ypos +' hgtaxis +' halflen in
    let ybot = ypos +' hgtaxis -' halflen in
      start-path (x2, ytop)
        |> line-to (x0, ytop)
        |> line-to (x0, ybot)
        |> line-to (x1, ybot)
        |> line-to (x1, ytop -' t)
        |> line-to (x2, ytop -' t)
        |> close-with-line


  val bracket-left pathf (hgt : length) (dpt : length) (hgtaxis : length) (fontsize : length) (color : color) =
    let halflen = half-length hgt dpt hgtaxis fontsize in
    let (w0, w1, w2, t) = bracket-metrics fontsize halflen in
    let path (xpos, ypos) =
      let x0 = xpos +' w0 in
      let x1 = x0 +' w1 in
      let x2 = x1 +' w2 in
        pathf x0 x1 x2 t ypos hgtaxis halflen
    in
    let graphics point = fill color (path point) in
    let widparen = w0 +' w1 +' w2 in
    (inline-graphics widparen (hgtaxis +' halflen) (halflen -' hgtaxis) graphics, (fun _ -> 0pt))


  val bracket-right pathf hgt dpt hgtaxis fontsize color =
    let halflen = half-length hgt dpt hgtaxis fontsize in
    let (w0, w1, w2, t) = bracket-metrics fontsize halflen in
    let widparen = w0 +' w1 +' w2 in
    let path (xpos, ypos) =
      let x0 = xpos +' widparen -' w0 in
      let x1 = x0 -' w1 in
      let x2 = x1 -' w2 in
        pathf x0 x1 x2 t ypos hgtaxis halflen
    in
    let graphics point = fill color (path point) in
    (inline-graphics widparen (hgtaxis +' halflen) (halflen -' hgtaxis) graphics, (fun _ -> 0pt))


  val sqbracket-left = bracket-left bracket-path
  val sqbracket-right = bracket-right bracket-path
  val math \sqbracket =
    math-paren sqbracket-left sqbracket-right


  val floor-left hgt = bracket-left floor-path hgt
  val floor-right hgt = bracket-right floor-path hgt
  val math \floor =
    math-paren floor-left floor-right


  val ceil-left = bracket-left ceil-path
  val ceil-right = bracket-right ceil-path
  val math \ceil =
    math-paren ceil-left ceil-right


  val empty-paren _ _ _ _ _ = (inline-nil, (fun _ -> 0pt))


  val abs-left hgt dpt hgtaxis fontsize color =
    let halflen = half-length hgt dpt hgtaxis fontsize in
    let wid = 5.0pt in
    let path (xpos, ypos) =
      start-path (xpos +' wid *' 0.5, ypos +' hgtaxis +' halflen)
        |> line-to (xpos +' wid *' 0.5, ypos +' hgtaxis -' halflen)
        |> close-with-line
    in
    let graphics point = stroke 0.5pt color (path point) in
    let kerninfo _ = 0pt in
    (inline-graphics wid (hgtaxis +' halflen) (halflen -' hgtaxis) graphics, kerninfo)


  val abs-right hgt dpt hgtaxis fontsize color =
    let halflen = half-length hgt dpt hgtaxis fontsize in
    let wid = 5.0pt in
    let path (xpos, ypos) =
      start-path (xpos +' wid *' 0.5, ypos +' hgtaxis +' halflen)
        |> line-to (xpos +' wid *' 0.5, ypos +' hgtaxis -' halflen)
        |> close-with-line
    in
    let graphics point = stroke 0.5pt color (path point) in
    let kerninfo _ = 0pt in
    (inline-graphics wid (hgtaxis +' halflen) (halflen -' hgtaxis) graphics, kerninfo)


  val math \abs =
    math-paren abs-left abs-right


  val norm-left hgt dpt hgtaxis fontsize color =
    let halflen = half-length hgt dpt hgtaxis fontsize in
    let wid = 7.0pt in
    let path (xpos, ypos) =
      unite-path (
        start-path (xpos +' wid *' 0.5 -' 1.2pt, ypos +' hgtaxis +' halflen)
          |> line-to (xpos +' wid *' 0.5 -' 1.2pt, ypos +' hgtaxis -' halflen)
          |> close-with-line
      ) (
        start-path (xpos +' wid *' 0.5 +' 1.2pt, ypos +' hgtaxis +' halflen)
          |> line-to (xpos +' wid *' 0.5 +' 1.2pt, ypos +' hgtaxis -' halflen)
          |> close-with-line
      )
    in
    let graphics point = stroke 0.5pt color (path point) in
    let kerninfo _ = 0pt in
    (inline-graphics wid (hgtaxis +' halflen) (halflen -' hgtaxis) graphics, kerninfo)


  val norm-right hgt dpt hgtaxis fontsize color =
    let halflen = half-length hgt dpt hgtaxis fontsize in
    let wid = 7.0pt in
    let path (xpos, ypos) =
      unite-path (
        start-path (xpos +' wid *' 0.5 -' 1.2pt, ypos +' hgtaxis +' halflen)
          |> line-to (xpos +' wid *' 0.5 -' 1.2pt, ypos +' hgtaxis -' halflen)
          |> close-with-line
      ) (
        start-path (xpos +' wid *' 0.5 +' 1.2pt, ypos +' hgtaxis +' halflen)
          |> line-to (xpos +' wid *' 0.5 +' 1.2pt, ypos +' hgtaxis -' halflen)
          |> close-with-line
      )
    in
    let graphics point = stroke 0.5pt color (path point) in
    let kerninfo _ = 0pt in
    (inline-graphics wid (hgtaxis +' halflen) (halflen -' hgtaxis) graphics, kerninfo)


  val math \norm =
    math-paren norm-left norm-right


  val math \set m =
    ${\brace{#m}}


  val math \cases lst =
    let m-inner =
      text-in-math MathInner (fun ctx -> (
        let size = get-font-size ctx in
        let pads = (0pt, 0pt, size *' 0.25, size *' 0.25) in
        let celllstlst =
          lst |> List.map (fun (m, it) -> (
            let ib1 = embed-math ctx m ++ inline-fil in
            let ib2 = inline-skip size ++ read-inline ctx it ++ inline-fil in
              [NormalCell(pads, ib1), NormalCell(pads, ib2)]
          ))
        in
        let ib = tabular celllstlst (fun _ _ -> []) in
        let (_, hgt, dpt) = get-natural-metrics ib in
        let hgtaxis = get-axis-height ctx in
          raise-inline (hgtaxis -' (hgt +' dpt) *' 0.5) ib

      ))
    in
    math-paren brace-left empty-paren m-inner


end
